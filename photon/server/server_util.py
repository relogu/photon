"""Utility functions for running the main server loop in flwr next."""

import gc
import time
from collections.abc import Callable, Generator
from dataclasses import asdict
from logging import DEBUG
from typing import cast

from flwr.common import (
    DEFAULT_TTL,
    ConfigsRecord,
    EvaluateIns,
    FitIns,
    Message,
    Parameters,
    RecordSet,
    log,
)
from flwr.common.recordset_compat import evaluateins_to_recordset, fitins_to_recordset
from flwr.common.typing import ConfigsRecordValues
from flwr.server import Driver

from photon.utils import ClientState

PARAMETERS = "parameters"
COMM_ = "comm_"
COMM_STACK = "comm_stack"


class TooManyFailuresError(Exception):
    """Exception raised when a client is dropped out of the tree."""


def wait_for_nodes_to_connect(driver: Driver, n_nodes: int, timeout: float = 3) -> None:
    """Wait for a specified number of client nodes to connect.

    This function continuously checks the number of client nodes that have connected by
    calling the `get_node_ids` method on the provided driver object. It logs the current
    number of connected client nodes at each check. The function will exit once the
    number of connected client nodes meets or exceeds the specified `n_nodes`. If the
    required number of nodes are not found, the function will wait for the specified
    `timeout` period before checking again.

    Parameters
    ----------
    driver : Driver
        The driver object used to interact with the client nodes.
    n_nodes : int
        The minimum number of client nodes that must be connected.
    timeout : float, optional
        The time in seconds to wait between checks. Default is 3 seconds.

    """
    # The Driver API might not immediately return enough client node IDs, so we
    # loop and wait until enough client nodes are available.
    while True:
        all_node_ids = driver.get_node_ids()
        log(DEBUG, f"Got {len(all_node_ids)} client nodes: {all_node_ids}")
        if len(all_node_ids) >= n_nodes:
            break
        time.sleep(timeout)


def message_collaborative(  # noqa: PLR0913, PLR0917
    driver: Driver,
    message_type: str,
    sampled_clients: list[int] | list[str],
    gen_ins_function: Callable[[int, int | str], dict[str, ConfigsRecordValues]],
    all_node_ids: list[int],
    current_round: int,
    client_state: dict[str | int, ClientState],
    server_steps_cumulative: int,
    msg_str: str,
) -> Generator[Message, None, None]:
    """Generate and send collaborative messages to the nodes and handles the responses.

    This function is designed for federated learning scenarios where a server needs to
    communicate with a subset of clients for training or evaluation purposes. It
    generates messages based on the provided message type and instructions, sends them
    to the sampled clients, and yields the responses received. The function supports
    dynamic message generation based on the current round of communication and the
    specific needs of each client.

    Parameters
    ----------
    driver : Driver
        The communication driver used for message creation, sending, and receiving.
    message_type : str
        The type of message to be sent (e.g., "fit", "evaluate").
    sampled_clients : list[int] | list[str]
        A list of client identifiers (either integers or strings) that have been sampled
        for participation in the current round.
    gen_ins_function : Callable[[int, int | str], dict[str, ConfigsRecordValues]]
        A function that generates instruction configurations for each client based on
        the current round and the client's identifier.
    all_node_ids : list[int]
        A list of all node identifiers in the network.
    current_round : int
        The current round of the federated learning process.
    client_state : dict[str | int, ClientState]
        A dictionary mapping client identifiers to their current state.
    server_steps_cumulative : int
        The cumulative number of steps completed by the server.
    msg_str : str
        A string identifier used to prefix keys in the message's content and to locate
        specific parameters within the recordset.

    Yields
    ------
    Generator[Message, None, None]
        A generator that yields responses received from the clients as Message objects.

    Notes
    -----
    - The function constructs separate record sets for each client based on the
        instructions generated by `gen_ins_function` and updates these with
        configuration records.
    - It then creates messages for all nodes in `all_node_ids` using these record sets
        and sends them using the driver. The function handles the responses, sending
        additional messages if necessary, and yields the responses received.
    - This function is part of a larger federated learning framework and assumes the
        existence of `Driver`, `Message`, `RecordSet`, `ConfigsRecord`, and
        `ClientState` classes or interfaces.

    """
    log(DEBUG, "Collaborative messaging.")
    # Constructing separate record sets for each client
    record_sets: list[RecordSet] = []
    for cid in sampled_clients:
        record_set = fit_or_evaluate_ins_recordset(
            msg_str,
            current_round,
            cast("list[int] | list[str]", [cid]),
            client_state,
            server_steps_cumulative,  # type: ignore[reportArgumentType, arg-type]
        )
        # Create a config record for the client
        record_set.configs_records.update(
            {str(cid): ConfigsRecord(gen_ins_function(current_round, cid))},
        )
        record_sets.append(record_set)

    messages: list[Message] = []
    for node_id in all_node_ids:
        if not record_sets:
            break
        message = driver.create_message(
            content=record_sets.pop(),
            message_type=message_type,
            dst_node_id=node_id,
            group_id=str(current_round),
            ttl=DEFAULT_TTL,
        )
        messages.append(message)
    message_ids = list(driver.push_messages(messages))
    received = 0
    total = len(sampled_clients)
    log(DEBUG, "Pushed %s messages: %s", len(messages), message_ids)
    # GC collect
    gc.collect()

    while received < total:
        replies = list(driver.pull_messages(message_ids=message_ids))
        if replies:
            # log(DEBUG, "Got %s replies: %s", len(replies), replies)  # noqa: ERA001
            log(DEBUG, "Got %s replies", len(replies))
            # Get message IDs to remove
            message_ids_to_remove = [
                reply.metadata.reply_to_message for reply in replies
            ]
            # Remove the message IDs from the list of message IDs
            message_ids = [
                mid for mid in message_ids if mid not in message_ids_to_remove
            ]
        messages = []
        for res in replies:
            log(
                DEBUG,
                "Got 1 %s from %s",
                "result" if res.has_content() else "error",
                res.metadata.src_node_id,
            )
            received += 1
            node_id = res.metadata.src_node_id
            if record_sets:
                message = driver.create_message(
                    content=record_sets.pop(),
                    message_type=message_type,
                    dst_node_id=node_id,
                    group_id=str(current_round),
                    ttl=DEFAULT_TTL,
                )
                messages.append(message)
        if messages:
            # Push the messages to the driver
            new_message_ids = driver.push_messages(messages)
            # Add the new message IDs to the list of message IDs
            message_ids.extend(new_message_ids)
            log(DEBUG, "Pushed another %s messages: %s", len(messages), message_ids)
        for res in replies:
            yield res


def fit_or_evaluate_ins_recordset(
    msg_str: str,
    current_round: int,
    sampled_clients: list[int] | list[str],
    client_state: dict[str | int, ClientState],
    server_steps_cumulative: int,
) -> RecordSet:
    """Create a RecordSet for fit or evaluation instructions based on the message type.

    This function generates a RecordSet for either fitting or evaluation instructions,
    depending on the message string provided (`msg_str`). It supports creating
    instructions for a list of sampled clients, incorporating the current server round
    and client IDs into the configuration of the instructions. The function is designed
    to work with federated learning scenarios where instructions need to be dynamically
    generated and dispatched to clients based on the current round of training or
    evaluation.

    Parameters
    ----------
    msg_str : str
        A string indicating the type of instructions to generate. Expected values are
        "fitins" for fitting instructions or "evaluateins" for evaluation instructions.
    current_round : int
        The current round of the federated learning process. This is used to track the
        progress of the learning or evaluation over time.
    sampled_clients : list[int] | list[str]
        A list of client identifiers (either integers or strings) that have been sampled
        for participation in the current round. These identifiers are included in the
        instructions to specify the target clients.
    client_state : dict[str | int, ClientState]
        A dictionary mapping client identifiers to their current state information. This
        information is included in the instructions to provide context to the clients
        about their previous interactions with the server.
    server_steps_cumulative : int
        The cumulative number of training steps performed by the server across all
        rounds. This value is included in the instructions to provide context to the
        clients.

    Returns
    -------
    RecordSet
        A RecordSet object containing the generated instructions for fitting or
        evaluation. The RecordSet includes parameters and configuration tailored to the
        specified clients and the current round.


    Notes
    -----
    - The function uses `fitins_to_recordset` and `evaluateins_to_recordset` to convert
        fitting or evaluation instructions into a RecordSet format suitable for
        transmission to clients.
    - The `parameters` field of the instructions is initialized with an empty tensor,
        indicating that no initial parameters are provided to the clients.
    - The configuration includes the `server_round` to inform clients of the current
        round and `client_ids` to specify the target clients for these instructions.
    - This function is part of a federated learning server utility and assumes the
        existence of `FitIns`, `EvaluateIns`, `Parameters`, `RecordSet`,
        `fitins_to_recordset`, and `evaluateins_to_recordset` classes or functions.

    """
    recordset: RecordSet | None = None
    match msg_str:
        case "fitins":
            # Create shared recordset for all clients in this assignment
            recordset = fitins_to_recordset(
                FitIns(
                    parameters=Parameters(tensors=[], tensor_type="empty"),
                    # NOTE: We always need to pass the server round to the config record
                    config={
                        "server_round": current_round,
                        "client_ids": str(sampled_clients),
                        "client_state": str(
                            {k: asdict(v) for k, v in client_state.items()},
                        ),
                        "server_steps_cumulative": server_steps_cumulative,
                    },
                ),
                keep_input=True,
            )
        case "evaluateins":
            # Create shared recordset for all clients in this assignment
            recordset = evaluateins_to_recordset(
                EvaluateIns(
                    parameters=Parameters(tensors=[], tensor_type="empty"),
                    # NOTE: We always need to pass the server round to the config record
                    config={
                        "server_round": current_round,
                        "client_ids": str(sampled_clients),
                        "client_state": str(
                            {k: asdict(v) for k, v in client_state.items()},
                        ),
                        "server_steps_cumulative": server_steps_cumulative,
                    },
                ),
                keep_input=True,
            )
    assert recordset is not None, "Recordset must be created"
    return recordset
